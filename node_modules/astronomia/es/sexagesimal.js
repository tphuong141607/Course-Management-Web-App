function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module sexagesimal
 */

/**
 * Sexagesimal functions
 */

/**
 * Angle represents a general purpose angle.
 * Unit is radians.
 */
export var Angle =
/*#__PURE__*/
function () {
  /**
  * constructs a new Angle value from sign, degree, minute, and second
  * components.
  * __One argument__
  * @param {Number} angle - (float) angle in radians
  * __Four arguments__
  * @param {Boolean} neg - sign, true if negative (required to attribute -0°30')
  * @param {Number} d - (int) degree
  * @param {Number} m - (int) minute
  * @param {Number} s - (float) second
  */
  function Angle(neg, d, m, s) {
    if (arguments.length === 1) {
      this.angle = neg;
    } else {
      this.setDMS(neg, d, m, s);
    }
  }
  /**
   * SetDMS sets the value of an FAngle from sign, degree, minute, and second
   * components.
   * The receiver is returned as a convenience.
   * @param {Boolean} neg - sign, true if negative
   * @param {Number} d - (int) degree
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   * @returns {Angle}
   */


  var _proto = Angle.prototype;

  _proto.setDMS = function setDMS(neg, d, m, s) {
    if (neg === void 0) {
      neg = 0;
    }

    if (d === void 0) {
      d = 0;
    }

    if (m === void 0) {
      m = 0;
    }

    if (s === void 0) {
      s = 0.0;
    }

    this.angle = DMSToDeg(neg, d, m, s) * Math.PI / 180;
    return this;
  }
  /**
   * sets angle
   * @param {Number} angle - (float) angle in radians
   * @returns {Angle}
   */
  ;

  _proto.setAngle = function setAngle(rad) {
    this.angle = rad;
    return this;
  }
  /**
   * Rad returns the angle in radians.
   * @returns {Number} angle in radians
   */
  ;

  _proto.rad = function rad() {
    return this.angle;
  }
  /**
   * Deg returns the angle in degrees.
   * @returns {Number} angle in degree
   */
  ;

  _proto.deg = function deg() {
    return this.angle * 180 / Math.PI;
  }
  /**
   * toDMS converts to parsed sexagesimal angle component.
   */
  ;

  _proto.toDMS = function toDMS() {
    return degToDMS(this.deg());
  }
  /**
   * Print angle in degree using `d°m´s.ss″`
   * @param {Number} precision - precision of `s.ss`
   * @returns {String}
   */
  ;

  _proto.toString = function toString(precision) {
    var _this$toDMS = this.toDMS(),
        neg = _this$toDMS[0],
        d = _this$toDMS[1],
        m = _this$toDMS[2],
        s = _this$toDMS[3];

    s = round(s, precision).toString().replace(/^0\./, '.');
    var str = (neg ? '-' : '') + (d + '°') + (m + '′') + (s + '″');
    return str;
  }
  /**
   * Print angle in degree using `d°.ff`
   * @param {Number} precision - precision of `.ff`
   * @returns {String}
   */
  ;

  _proto.toDegString = function toDegString(precision) {
    var _modf = modf(this.deg()),
        i = _modf[0],
        s = _modf[1];

    s = round(s, precision).toString().replace(/^0\./, '.');
    var str = i + '°' + s;
    return str;
  };

  return Angle;
}();
/**
 * HourAngle represents an angle corresponding to angular rotation of
 * the Earth in a specified time.
 *
 * Unit is radians.
 */

export var HourAngle =
/*#__PURE__*/
function (_Angle) {
  _inheritsLoose(HourAngle, _Angle);

  function HourAngle() {
    return _Angle.apply(this, arguments) || this;
  }

  var _proto2 = HourAngle.prototype;

  /**
  * NewHourAngle constructs a new HourAngle value from sign, hour, minute,
  * and second components.
  * @param {Boolean} neg
  * @param {Number} h - (int)
  * @param {Number} m - (int)
  * @param {Number} s - (float)
  */
  // constructor (neg, h, m, s) {
  // super(neg, h, m, s)
  // }

  /**
   * SetDMS sets the value of an FAngle from sign, degree, minute, and second
   * components.
   * The receiver is returned as a convenience.
   * @param {Boolean} neg - sign, true if negative
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   * @returns {Angle}
   */
  _proto2.setDMS = function setDMS(neg, h, m, s) {
    if (neg === void 0) {
      neg = 0;
    }

    if (h === void 0) {
      h = 0;
    }

    if (m === void 0) {
      m = 0;
    }

    if (s === void 0) {
      s = 0.0;
    }

    this.angle = DMSToDeg(neg, h, m, s) * 15 * Math.PI / 180;
    return this;
  }
  /**
   * Hour returns the hour angle as hours of time.
   * @returns hour angle
   */
  ;

  _proto2.hour = function hour() {
    return this.angle * 12 / Math.PI; // 12 = 180 / 15
  };

  _proto2.deg = function deg() {
    return this.hour();
  }
  /**
   * Print angle in `HʰMᵐs.ssˢ`
   * @param {Number} precision - precision of `s.ss`
   * @returns {String}
   */
  ;

  _proto2.toString = function toString(precision) {
    var _this$toDMS2 = this.toDMS(),
        neg = _this$toDMS2[0],
        h = _this$toDMS2[1],
        m = _this$toDMS2[2],
        s = _this$toDMS2[3];

    s = round(s, precision).toString().replace(/^0\./, '.');
    var str = (neg ? '-' : '') + (h + 'ʰ') + (m + 'ᵐ') + (s + 'ˢ');
    return str;
  };

  return HourAngle;
}(Angle);
/**
 * DMSToDeg converts from parsed sexagesimal angle components to decimal
 * degrees.
 * @param {Boolean} neg - sign, true if negative
 * @param {Number} d - (int) degree
 * @param {Number} m - (int) minute
 * @param {Number} s - (float) second
 * @returns {Number} angle in degree
 */

export function DMSToDeg(neg, d, m, s) {
  s = ((d * 60 + m) * 60 + s) / 3600;

  if (neg) {
    return -s;
  }

  return s;
}
/**
 * DegToDMS converts from decimal degrees to parsed sexagesimal angle component.
 * @param {Number} deg - angle in degree
 * @returns {Array} [neg, d, m, s]
 *  {Boolean} neg - sign, true if negative
 *  {Number} d - (int) degree
 *  {Number} m - (int) minute
 *  {Number} s - (float) second
 */

export function degToDMS(deg) {
  var neg = deg < 0;
  deg = Math.abs(deg);

  var _modf2 = modf(deg % 360),
      d = _modf2[0],
      s = _modf2[1];

  var _modf3 = modf(s * 60),
      m = _modf3[0],
      s1 = _modf3[1];

  s = round(s1 * 60); // may introduce an error < 1e13

  return [neg, d, m, s];
}
/**
 * TODO
 */

export var RA =
/*#__PURE__*/
function (_HourAngle) {
  _inheritsLoose(RA, _HourAngle);

  /**
   * constructs a new RA value from hour, minute, and second components.
   * Negative values are not supported, RA wraps values larger than 24
   * to the range [0,24) hours.
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   */
  function RA(h, m, s) {
    var _this;

    if (h === void 0) {
      h = 0;
    }

    if (m === void 0) {
      m = 0;
    }

    if (s === void 0) {
      s = 0;
    }

    _this = _HourAngle.call(this) || this;
    var args = [].slice.call(arguments);

    if (args.length === 1) {
      _this.angle = h;
    } else {
      var hr = DMSToDeg(false, h, m, s) % 24;
      _this.angle = hr * 15 * Math.PI / 180;
    }

    return _this;
  }

  var _proto3 = RA.prototype;

  _proto3.hour = function hour() {
    var h = this.angle * 12 / Math.PI;
    return (24 + h % 24) % 24;
  };

  return RA;
}(HourAngle);
/**
 * Time Angle
 * Unit is time in seconds.
 */

export var Time =
/*#__PURE__*/
function () {
  /**
   * @param {Boolean} neg - set `true` if negative
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   */
  function Time(neg, h, m, s) {
    if (arguments.length === 1) {
      this.time = neg;
    } else {
      this.setHMS(neg, h, m, s);
    }
  }

  var _proto4 = Time.prototype;

  _proto4.setHMS = function setHMS(neg, h, m, s) {
    if (neg === void 0) {
      neg = false;
    }

    if (h === void 0) {
      h = 0;
    }

    if (m === void 0) {
      m = 0;
    }

    if (s === void 0) {
      s = 0;
    }

    s += (h * 60 + m) * 60;

    if (neg) {
      s = -s;
    }

    this.time = s;
  }
  /**
   * @returns {Number} time in seconds.
   */
  ;

  _proto4.sec = function sec() {
    return this.time;
  }
  /**
   * @returns {Number} time in minutes.
   */
  ;

  _proto4.min = function min() {
    return this.time / 60;
  }
  /**
   * @returns {Number} time in hours.
   */
  ;

  _proto4.hour = function hour() {
    return this.time / 3600;
  }
  /**
   * @returns {Number} time in days.
   */
  ;

  _proto4.day = function day() {
    return this.time / 3600 / 24;
  }
  /**
   * @returns {Number} time in radians, where 1 day = 2 Pi radians.
   */
  ;

  _proto4.rad = function rad() {
    return this.time * Math.PI / 12 / 3600;
  }
  /**
   * convert time to HMS
   * @returns {Array} [neg, h, m, s]
   *  {Boolean} neg - sign, true if negative
   *  {Number} h - (int) hour
   *  {Number} m - (int) minute
   *  {Number} s - (float) second
   */
  ;

  _proto4.toHMS = function toHMS() {
    var t = this.time;
    var neg = t < 0;
    t = neg ? -t : t;
    var h = Math.trunc(t / 3600);
    t = t - h * 3600;
    var m = Math.trunc(t / 60);
    var s = t - m * 60;
    return [neg, h, m, s];
  }
  /**
   * Print time using `HʰMᵐsˢ.ss`
   * @param {Number} precision - precision of `.ss`
   * @returns {String}
   */
  ;

  _proto4.toString = function toString(precision) {
    var _this$toHMS = this.toHMS(),
        neg = _this$toHMS[0],
        h = _this$toHMS[1],
        m = _this$toHMS[2],
        s = _this$toHMS[3];

    var _modf4 = modf(s),
        si = _modf4[0],
        sf = _modf4[1];

    if (precision === 0) {
      si = round(s, 0);
      sf = 0;
    } else {
      sf = round(sf, precision).toString().substr(1);
    }

    var str = (neg ? '-' : '') + (h + 'ʰ') + (m + 'ᵐ') + (si + 'ˢ') + (sf || '');
    return str;
  };

  return Time;
}(); // units

export var angleFromDeg = function angleFromDeg(deg) {
  return deg * Math.PI / 180;
};
export var angleFromMin = function angleFromMin(min) {
  return min / 60 * Math.PI / 180;
};
export var angleFromSec = function angleFromSec(sec) {
  return sec / 3600 * Math.PI / 180;
};
export var degFromAngle = function degFromAngle(angle) {
  return angle * 180 / Math.PI;
};
export var secFromAngle = function secFromAngle(angle) {
  return angle * 3600 * 180 / Math.PI;
};
export var secFromHourAngle = function secFromHourAngle(ha) {
  return ha * 240 * 180 / Math.PI;
};
/**
 * separate fix `i` from fraction `f`
 * @private
 * @param {Number} float
 * @returns {Array} [i, f]
 *  {Number} i - (int) fix value
 *  {Number} f - (float) fractional portion; always > 1
 */

function modf(float) {
  var i = Math.trunc(float);
  var f = Math.abs(float - i);
  return [i, f];
}
/**
 * Rounds `float` value by precision
 * @private
 * @param {Number} float - value to round
 * @param {Number} precision - (int) number of post decimal positions
 * @return {Number} rounded `float`
 */


function round(float, precision) {
  precision = precision === undefined ? 10 : precision;
  return parseFloat(float.toFixed(precision), 10);
}

export default {
  Angle: Angle,
  HourAngle: HourAngle,
  DMSToDeg: DMSToDeg,
  degToDMS: degToDMS,
  RA: RA,
  Time: Time,
  angleFromDeg: angleFromDeg,
  angleFromMin: angleFromMin,
  angleFromSec: angleFromSec,
  degFromAngle: degFromAngle,
  secFromAngle: secFromAngle,
  secFromHourAngle: secFromHourAngle
};