"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFK5 = toFK5;
exports["default"] = exports.Planet = void 0;

var _base = _interopRequireDefault(require("./base"));

var _sexagesimal = _interopRequireDefault(require("./sexagesimal"));

var _coord = _interopRequireDefault(require("./coord"));

var _precess = _interopRequireDefault(require("./precess"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function sum(t, series) {
  var coeffs = [];
  Object.keys(series).forEach(function (x) {
    coeffs[x] = 0;
    var y = series[x].length - 1;

    for (y; y >= 0; y--) {
      var term = {
        a: series[x][y][0],
        b: series[x][y][1],
        c: series[x][y][2]
      };
      coeffs[x] += term.a * Math.cos(term.b + term.c * t);
    }
  });

  var res = _base["default"].horner(t, coeffs);

  return res;
}

var Planet =
/*#__PURE__*/
function () {
  /**
   * VSOP87 representation of a Planet
   * @constructs Planet
   * @param {object} planet - planet data series
   * @example
   * ```js
   * // for use in browser
   * import {data} from 'astronomia'
   * const earth = new planetposition.Planet(data.vsop87Bearth)
   * ```
   */
  function Planet(planet) {
    _classCallCheck(this, Planet);

    if (_typeof(planet) !== 'object') throw new TypeError('need planet vsop87 data');
    this.name = planet.name;
    this.series = planet;
  }
  /**
   * Position2000 returns ecliptic position of planets by full VSOP87 theory.
   *
   * @param {Number} jde - the date for which positions are desired.
   * @returns {base.Coord} Results are for the dynamical equinox and ecliptic J2000.
   *  {Number} lon - heliocentric longitude in radians.
   *  {Number} lat - heliocentric latitude in radians.
   *  {Number} range - heliocentric range in AU.
   */


  _createClass(Planet, [{
    key: "position2000",
    value: function position2000(jde) {
      var T = _base["default"].J2000Century(jde);

      var τ = T * 0.1;

      var lon = _base["default"].pmod(sum(τ, this.series.L), 2 * Math.PI);

      var lat = sum(τ, this.series.B);
      var range = sum(τ, this.series.R);
      return new _base["default"].Coord(lon, lat, range);
    }
    /**
     * Position returns ecliptic position of planets at equinox and ecliptic of date.
     *
     * @param {Number} jde - the date for which positions are desired.
     * @returns {base.Coord} Results are positions consistent with those from Meeus's
     * Apendix III, that is, at equinox and ecliptic of date.
     *  {Number} lon - heliocentric longitude in radians.
     *  {Number} lat - heliocentric latitude in radians.
     *  {Number} range - heliocentric range in AU.
     */

  }, {
    key: "position",
    value: function position(jde) {
      var _this$position = this.position2000(jde),
          lat = _this$position.lat,
          lon = _this$position.lon,
          range = _this$position.range;

      var eclFrom = new _coord["default"].Ecliptic(lon, lat);
      var epochFrom = 2000.0;

      var epochTo = _base["default"].JDEToJulianYear(jde);

      var eclTo = _precess["default"].eclipticPosition(eclFrom, epochFrom, epochTo, 0, 0);

      return new _base["default"].Coord(eclTo.lon, eclTo.lat, range);
    }
  }]);

  return Planet;
}();
/**
 * ToFK5 converts ecliptic longitude and latitude from dynamical frame to FK5.
 *
 * @param {Number} lon - ecliptic longitude in radians
 * @param {Number} lat - ecliptic latitude in radians
 * @param {Number} jde - Julian ephemeris day
 * @return {base.Coord}
 *    {Number} lon - FK5 longitude
 *    {Number} lat - FK5 latitude
 */


exports.Planet = Planet;

function toFK5(lon, lat, jde) {
  // formula 32.3, p. 219.
  var T = _base["default"].J2000Century(jde); // const Lp = lon - 1.397 * Math.PI / 180 * T - 0.00031 * Math.PI / 180 * T * T


  var Lp = lon - _sexagesimal["default"].angleFromDeg((1.397 + 0.00031 * T) * T);

  var _base$sincos = _base["default"].sincos(Lp),
      _base$sincos2 = _slicedToArray(_base$sincos, 2),
      sLp = _base$sincos2[0],
      cLp = _base$sincos2[1]; // (32.3) p. 219


  var L5 = lon + _sexagesimal["default"].angleFromSec(-0.09033 + 0.03916 * (cLp + sLp) * Math.tan(lat));

  var B5 = lat + _sexagesimal["default"].angleFromSec(0.03916 * (cLp - sLp));

  return new _base["default"].Coord(L5, B5);
}

var _default = {
  Planet: Planet,
  toFK5: toFK5
};
exports["default"] = _default;